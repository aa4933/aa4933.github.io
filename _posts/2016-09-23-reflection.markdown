---
layout:     post
title:      "依赖注入/控制反转"
subtitle:   "reflection"
date:       2016-09-23 18:11:00
author:     "wulihh"
header-img: "img/post-bg-2016-07_09.jpg"
tags:
    - PHP
---
> 'About reflection'


##### 有关于依赖注入和控制反转

说起这2个名词，初次接触到的时候真的被唬到了，真厉害，真牛x，真帅气

逢人便问这几个名词，百分之80的人其实并不知道

现在总结一下对这几个名词的看法与具体实现方式


##### 自己认为的起源与发展

关于这几个名词的起源，其实最早来源于`java`的`Spring`框架，ssh框架中的S实现了`容器`的思想

关于后来的发展我个人认为是我们是以下的几种认知过程


* new时代


就是我们最早实现的new一个对象出来，这个就是最最最基本的面向对象的思想

软件开发的思想：高内聚，低耦合

据说耦合这样会很高，不敢妄下定论，可能是因为类与类之间功能的重合度很高，导致后期修改代价很大


* 工厂时代

工厂时代就是框架使用的一种设计模式，工厂模式和单例模式的结合，机制原理是`反射类`

本身这种架构的原理已经完全够用，也许是后来出现了多重超大型项目，导致资源调配整合上出现问题

就出现了我们常说的`依赖注入，控制反转`


* 服务容器时代

现在市面上流行的框架大多数采用的是这种架构，虽然也许有杀鸡用牛刀的嫌疑，不过牛刀顺手，兵器倒显得不那么重要了

大型框架具备 “依赖注入”，AOP(调用拦截)，对象生命周期的控制，其他的对象控制，还有有利于各种资源的整合

我们所用的工厂`反射类`，仅仅只是其中的一小部分


##### 形象生动的说法

之前在一些回答网站看到有人这么说

``` php
这个符合面向对象的思想。打个比方
你需要锤子，你可以
1、自己去造。用java的话说就是调用者创建被调用者
2、你可以要找到生产锤子的工厂，向工厂购买即可。对应java的工厂模式。
3、你可以打电话找到卖锤子的商店，让人把锤子送货上门。对应spring的依赖注入

以上第1种办法，要求被调用的Java类出现在调用者的代码里。无法实现二者之间的松耦合
第2种办法，调用者无须关心被调用者具体实现过程，只需要找到符合某种标准(接口)的实例，即可使用
第3种办法，调用者无须自己定位工厂，程序运行到需要被调用者时，系统自动提供被调用者实例。调用者和被调用者通过spring管理。他们的关系由spring维护

你自己想想，如果拿到的锤子不是你想要的，哪个办法更方便
```

好像也是有一点的道理，仅供参考

##### 总结

个人认为无论是什么吧，其实程序员创造这么一个东西绝对不是吃饱了撑着的

肯定是为了解决某一个场景下的问题，只不过你还没有遇到，或者说，你目前掌握的

完全足够解决你所遇到的场景，如果跳开这个场景，也许会不够用，也许你就会需要了

不过退一万步讲，当你真正有这个场景的时候，你已经在一家超大型国际互联网公司身居要职了

所以目前来看：能赚钱的技术就是好技术，说多了都是瞎扯蛋


